<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/ember-validator.js - Ember Validator</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="http://i1279.photobucket.com/albums/y523/textcraft/Jun%202014%20-%204/24ca5e6939aae8614e526a8cdc2c82b83bb591f6da39a3ee5e6b4b0d3255bfef95601890afd80709da39a3ee5e6b4b0d3255bfef95601890afd80709c824e6667975219e0101_zps7bc77bf6.png" title="Ember Validator"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.1.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Ember.Validator.html">Ember.Validator</a></li>
            
                <li><a href="../classes/Validator.Error.html">Validator.Error</a></li>
            
                <li><a href="../classes/Validator.Result.html">Validator.Result</a></li>
            
                <li><a href="../classes/Validator.Rule.html">Validator.Rule</a></li>
            
                <li><a href="../classes/Validator.Rules.html">Validator.Rules</a></li>
            
                <li><a href="../classes/Validator.Support.html">Validator.Support</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/Ember.Validator.html">Ember.Validator</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src/ember-validator.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
(function() {

var VERSION = &#x27;0.1.0&#x27;;

if (Ember.libraries) {
  Ember.libraries.register(&#x27;Ember Validator&#x27;, VERSION);
}

/**
 * @module Ember.Validator
 * @main Ember.Validator
 */

/**
 * @class Ember.Validator
 * @namespace Ember
 * @extends Ember.Object
 * @static
 */
Ember.Validator = Ember.Object.create({
  /**
   * Option to trim whitespace from string values before validation.
   * 
   * @property TRIM_VALUE
   * @type {Boolean}
   */
  TRIM_VALUE: true,
  
  /**
   * Looks for rules property in the errorKey set in validations
   *
   * @private
   * @method _getRulesForKey
   * @param {String} key
   */
  _getRulesForKey: function(validations, key) {
    var property = validations[key];

    if (Em.typeOf(property) === &#x27;array&#x27;) {
      return property;
    } else if (Em.typeOf(property.rules) === &#x27;array&#x27;) {
      return property.rules;
    } else {
      Em.Logger.warn(&#x27;No valid defined rules found for property \&#x27;&#x27; + key + &#x27;\&#x27;&#x27;);
      return [];
    }
  },
  
  /**
   * Creates the error message.
   * 
   * @private
   * @method _createResultMessage
   * @param {String} errorKey
   * @param {Ember.Validator.Rule} rule
   */
  _createResultMessage: function(errorKey, rule) {
    var propertyFormat = rule.get(&#x27;propertyFormat&#x27;),
        messageFormats = rule.get(&#x27;messageFormats&#x27;);
        
    propertyFormat = propertyFormat ? propertyFormat : errorKey;
      
    return this._formatMessage(rule, propertyFormat, messageFormats);
  },

  /**
   * Formats the message based on the errorKey and messageFormats.
   * The errorKey is always set as the first argument
   * 
   * Related:
   * {{#crossLink &quot;Validator.Rule/propertyFormat:property&quot;}}{{/crossLink}},
   * {{#crossLink &quot;Validator.Rule/messageFormats:property&quot;}}{{/crossLink}}
   * 
   * @private
   * @method _formatMessage
   * @param {Ember.Validator.Rule} rule
   * @param  {String} propertyFormat
   * @param  {Array} messageFormats
   * @return {String} The formatted string
   */
  _formatMessage: function(rule, propertyFormat, messageFormats) {
    var formats = [],
        message = rule.get(&#x27;message&#x27;);
        
    Em.assert(&#x27;You must specify an error message for rule name &#x27; + 
      &#x27;(%@)&#x27;.fmt(rule.get(&#x27;name&#x27;)), message);

    formats = formats.concat(messageFormats);
    formats.unshift(propertyFormat);

    return Em.String.fmt(message, formats);
  },
  
  /**
   * Looks for a rule object defined as custom or defined in {@link Em.Validator.Rules}.
   * Any custom rules with the same name in {@link Em.Validator.Rules} are merged.
   * 
   * @private
   * @method _getRuleObj
   * @param {String} context
   * @param {String} key
   * @param {String} ruleName
   * @return {Object} - The rule object
   */
  _getRuleObj: function(context, key, ruleName) {
    var validations = context.validations,
        Rules = Em.Validator.Rules,
        customRule = validations[key][ruleName],
        builtInRuleCopy = Em.copy(Rules[ruleName]);

    if (customRule) {
      var rule = builtInRuleCopy ? Em.merge(builtInRuleCopy, customRule) : customRule,
          hasValidateMethod = typeof rule.validate === &#x27;function&#x27;;

      Em.assert(&#x27;Must have validate function defined in custom rule.&#x27;, 
        hasValidateMethod);
        
      return Em.Validator.Rule.create(rule, { name: ruleName });
    }
    
    if (builtInRuleCopy) {
      return Em.Validator.Rule.create(builtInRuleCopy);
    } else {
      Em.assert(&#x27;No valid rules were found.&#x27;, false);
    }
  },
  
  /**
   * Responsible for running validation rules and adding the error to an
   * instance of Ember.Validator.Error.
   * 
   * Result generation will stop at the first failed validation per key.
   * 
   * @private
   * @method _generateResult
   * @param {Object} context - The object doing the validation
   * @param {Array} rules - rule names defined as strings
   * @param {String} key - the current property being validated
   */
  _generateResult: function(context, rules, key) {
    var self = this,
        valueForKey = context.get(key),
        results = context.get(&#x27;validatorResult&#x27;);

    if (Ember.Validator.TRIM_VALUE &amp;&amp; Em.typeOf(valueForKey) === &#x27;string&#x27;) {
      var trimmed = valueForKey.trim();
      context.set(key, trimmed);
      valueForKey = trimmed;
    }
    
    rules.find(function(ruleName) {
      var validator = self._getRuleObj(context, key, ruleName);

      // Should only run rules on required or values that are not undefined
      if (ruleName === &#x27;required&#x27; || valueForKey !== undefined) {
        // Build options to pass to validate
        var options = validator;
        
        options.context = context;

        var didValidate = validator.validate(valueForKey, options);

        if (!didValidate) {
          var message = self._createResultMessage(key, validator),
              result = Ember.Validator.Error.create();
              
          result.setProperties({
            message: message,
            context: context,
            isValid: false,
            ruleName: ruleName,
            errorKey: key
          });
          
          results.set(key, result);
          
          return true;
        }
      }
    });
  }
});

/**
 * The base rule class which stores the validate method and message settings.
 *
 * @class Rule
 * @constructor
 * @namespace Validator
 * @extends Ember.Object
 */
Ember.Validator.Rule = Ember.Object.extend({
  /** 
   * Property used to customize the message formatting
   * 
   * @property messageFormats
   * @type array
   */
  messageFormats: [],

  /**
   * Set this property when you want to customize the message to show something
   * other than the default errorKey.
   * 
   * See: {{#crossLink &quot;Ember.Validator.Error/errorKey:property&quot;}}errorKey{{/crossLink}}
   * 
   * @property propertyFormat
   * @type string
   */
  propertyFormat: null,

  /**
   * The property used to display the error message. Can be set to a customized
   * message with formatting or without.
   * 
   * message is formatted like so:
   * 
   * @example
   *  &#x60;&#x60;&#x60;
   *  // %@1: errorKey || propertyFormat
   *  // %@2+: messageFormats
   * 
   *  &#x27;%@1 has invalid length, must be %@2 %@3 chars&#x27;.fmt(errorKey, messageFormats);
   *  &#x60;&#x60;&#x60;
   * errorKey is defaulted to %@1 and messageFormats are designated for %@2+
   * 
   * Related: {{#crossLink &quot;Validator.Error/errorKey:property&quot;}}{{/crossLink}}
   *
   * @property message
   * @uses messageFormats
   * @type string
   */
  message: null,

  /**
   * Define validations in this method and return the Boolean value.
   * 
   * @method validate
   * @param {*} value - The property value to validate
   * @param {Object} options - The object validator with an object context included
   * @return {Boolean} 
   */
  validate: function() {
    Em.assert(&#x27;You must define a validate function for this to be a valid rule&#x27;, false);
  }
});

/**
 * A static class used to defined reusable rules. Each property defined on the
 * root of this class are wrapped in Ember.Validator.Rule.
 * 
 * An example of adding more rules:
 * 
 * &#x60;&#x60;&#x60;javascript
 * Ember.Validator.Rules.reopen({
 *   minLength: {
 *     min: 6,
 * 
 *     validate: function(value, options) {
 *       this.messageFormats = [&#x27;Minimum&#x27;, options.min];
 *       return value.split(&#x27;&#x27;).length &gt; options.min;
 *     },
 *     
 *     message: &#x27;%@2 of %@3 characters required.&#x27;
 *   }
 * });
 * &#x60;&#x60;&#x60;
 * 
 * Related:
 * {{#crossLink &quot;Validator.Rule&quot;}}{{/crossLink}},
 * http://emberjs.com/api/classes/Ember.String.html#method_fmt
 * 
 * @static
 * @class Rules
 * @namespace Validator
 */
Ember.Validator.Rules = Ember.Object.create({
  required: {
    validate: function(value) {
      return !Em.isEmpty(value);
    },
    
    message: &#x27;%@1 is required&#x27;
  },

  number: {
    validate: function(value) {
      return !isNaN(parseInt(value, 10));
    },

    message: &#x27;%@1 is not a number&#x27;
  }
});

/**
 * Validation result object used to store the validation.
 *
 * @class Error
 * @constructor
 * @namespace Validator
 * @extends Ember.Object
 */
Ember.Validator.Error = Ember.Object.extend({
  /**
   * @property message
   * @type String
   */
  message: null,
  
  /**
   * The object that is running the validation.
   * 
   * @property context
   * @type {Object || Ember.Object}
   */
  context: null,
  
  /**
   * @property errorKey
   * @type string
   */
  errorKey: null,
  
  /**
   * @property isValid
   * @type boolean
   */
  isValid: null,
  
  /**
   * @property ruleName
   * @type string
   */
  ruleName: null
});

/**
 * The array proxy which stores all the validation results
 * 
 * @constructor
 * @class Result
 * @namespace Validator
 * @extends Ember.ObjectProxy
 */
Ember.Validator.Result = Ember.ObjectProxy.extend({
  /**
   * All results are set in the content property.
   *
   * @property content
   * @type Object
   */
  content: null,
  
  /**
   * @property error
   * @type {Object}
   */
  error: Em.computed.alias(&#x27;content&#x27;),
  
  /**
   * An array of all errors that exist in the content property
   * 
   * @property errors
   * @type {Array}
   */
  errors: function() {
    var content = this.get(&#x27;content&#x27;);
    
    return Em.keys(content).reduce(function(errors, key) {
      errors.pushObject(content.get(key));
      return errors;
    }, []);
  }.property(&#x27;content&#x27;),
  
  /**
   * An array of all the error messages generated
   * 
   * @property messages
   * @type {Array}
   */
  messages: Em.computed.mapBy(&#x27;errors&#x27;, &#x27;message&#x27;),
  
  /**
   * Set to false if any errors were generated in the validation
   * 
   * @property isValid
   * @type {Boolean}
   */
  isValid: function() {
    return Em.isEmpty(this.get(&#x27;errors&#x27;));
  }.property(&#x27;errors.@each&#x27;)
});

/**
 * Add this mixin to any object to add validation support. Exposes the validate()
 * method which looks for a validations object.
 * 
 * @class Support
 * @static
 * @namespace Validator
 * @type {Ember.Mixin}
 */
Ember.Validator.Support = Ember.Mixin.create({
  init: function() {
    this._super();
    this.set(&#x27;validatorResult&#x27;, Ember.Validator.Result.create({ content: {} }));
  },
  
  /**
   * The property where validations are defined.
   * 
   * @example
   * &#x60;&#x60;&#x60;javascript
   * App.Person = Ember.Object.extend(Ember.Validator.Support, {
   *  name: null,
   *  phone: null,
   * 
   *  validations: {
   *    name: {
   *      rules: [&#x27;required&#x27;]
   *    },
   *    phone: {
   *       rules: [&#x27;required&#x27;, &#x27;phone&#x27;]
   *       phone: function(value, options) {
   *         // run validations
   *       }
   *    }
   *  }
   * });
   * &#x60;&#x60;&#x60;
   * 
   * @property validations
   * @required
   * @type {Object}
   */
  validations: null,
  
  /**
   * Runs all validations defined in the validations object and stores results.
   * The method returns a results object.
   * 
   * @example Getting the validation
   * &#x60;&#x60;&#x60;
   * var person = App.Person.create({ name: null, age: 29 });
   * 
   * person.validate().get(&#x27;isValid&#x27;) // false;;
   * &#x60;&#x60;&#x60;
   * 
   * @example Getting the error message
   * &#x60;&#x60;&#x60;
   * person.validate().get(&#x27;error.name.message&#x27;); // &#x27;name is required&#x27;
   * &#x60;&#x60;&#x60;
   * 
   * Related:
   * {{#crossLink &quot;Validator.Results&quot;}}{{/crossLink}},
   * {{#crossLink &quot;Validator.Support/validations:property&quot;}}{{/crossLink}}
   * 
   * You can also choose which keys to run validations on by passing an array
   * or comma separated strings.
   * &#x60;&#x60;&#x60;
   * person.validate(&#x27;name&#x27;, &#x27;age&#x27;);
   *
   * // or as an array
   * var keys = [&#x27;name&#x27;, &#x27;age&#x27;];
   * person.validate(keys);
   * &#x60;&#x60;&#x60;
   * 
   * @method validate
   * @param {Array} keys - An array of object keys to validate
   * @return {Ember.Validator.Result}
   */
  validate: function() {
    var self = this,
        validations = this.get(&#x27;validations&#x27;),
        Validator = Ember.Validator,
        keys;
        
    Em.assert(&#x27;You do not have a \&#x27;validations\&#x27; object defined&#x27;, validations);
    
    // Check if keys are being sent as args in the method before checking
    // validations object.
    if (arguments.length &gt; 0) {
      keys = Em.typeOf(arguments[0]) === &#x27;array&#x27; ?
        arguments[0] : Array.prototype.slice.call(arguments);
    } else {
      keys = Em.keys(validations);
    }
    
    this.set(&#x27;validatorResult.content&#x27;, Ember.Validator.Error.create());
        
    keys.forEach(function(key) {
      var rules = Validator._getRulesForKey(validations, key);
      Validator._generateResult(self, rules, key);
    });
    
    return this.get(&#x27;validatorResult&#x27;);
  }
});

})();

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
